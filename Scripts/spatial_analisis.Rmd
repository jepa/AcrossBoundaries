---
title: "Spatial Analysis"
# output: html_notebook
output: html_document
---

```{r setup, include=FALSE}
MyFunctions::my_lib(c("ggmap","sf","tidyverse","tools","readr","data.table","maps","viridis"))
library(MyFunctions)
```


# Load data

## Ocean adapt data

- Using only "Northeast US Fall and Spring surveys for now

```{r dat_exploded, eval = T, echo = F}

ocean_data <- readRDS("/Volumes/Enterprise/Data/pinskylab-OceanAdapt-966adf0/data_clean/dat_exploded.rds") %>% 
  filter(spp == "Centropristis striata",
       region %in% c("Northeast US Fall" , "Northeast US Spring")) #No more seasons


```

## Maps data

```{r maps_sf, eval = T, echo = T, results = 'hide'}

States <- c("maine", "new hampshire", "massachusets", "connecticut", "rhode island", "new york", "new jersey", "delaware", "maryland", "virginia", "north carolina") 

# US State Map (land)

land_sf <- st_as_sf(map("state", plot = FALSE, fill = TRUE)) %>% 
  filter(ID %in% States) 

# ggplot(us_map) +
  # geom_sf()

# US EEZ map

# path_world <- MyFunctions::my_path("G", extra_path = "Spatial/SAU/SAU_Shapefile")
path_world <- "~/Downloads/SAU_Shapefile"

# The File
fnam_world <- "SAUEEZ_July2015.shp"

# Load it!
eez_sf <- st_read(dsn = path_world,
                        layer =file_path_sans_ext(fnam_world)) %>% 
  rename(eez_name = Name) %>% 
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 10000) %>% #0.1 for paper
  filter(eez_name == "USA (East Coast)")


# ggplot(eez_sf) +
# geom_sf(aes(),fill =NA)

# ggplot() +
#   geom_sf(data = World_eez_sf, aes(), color = "red") +
#   geom_sf(data = us_map, aes(), color = "blue")



# US state waters
# https://catalog.data.gov/dataset/federal-and-state-waters

# us_state_w <- rgdal::readOGR(dsn = "~/Downloads/FederalAndStateWaters/FederalAndStateWaters.gdb")
state_sf <-  st_read("~/Downloads/FederalAndStateWaters/FederalAndStateWaters.gdb") %>%
  janitor::clean_names() %>% 
  mutate(jurisdicti = str_to_lower(jurisdicti)) %>% 
  filter(jurisdicti %in% States) %>% 
  rename(state = jurisdicti) %>% 
  # st_transform(crs = 4326)  # for matching projections
  st_simplify(preserveTopology = TRUE, dTolerance = 10000) #0.1 for paper


grid_sf <-  st_read("/Volumes/Enterprise/Data/AcrossBoundaries/Data/Spatial/grid_sf/grid_eez_sf.shp")

```

## Create basis sf

In this first step we first combine the North East EEZ shapefile (SAU) with the state waters sf provided by [NOAA](link) and girded the area following these steps:

- 1. Expand state waters using a buffer

- 2. Grid that buffer on a 0.3 ressolution

- 3. Crop the buffer to the EEZ

### 1. Expand Spatial regions (a.k.a  buffers)

A buffer of *410000* m (410 KM / 221) overshoots the EEZ a bit, but is eventually cropped

```{r buffer, eval = T, echo = T}

# Buffer state waters
state_bf = st_buffer(state_sf, 410000) %>% 
  st_transform(4326) %>% # to match shape
  st_set_crs(4326)

# ------------------------------ #
# Testing and visualizing the buffer 
# ------------------------------ #

state_bf_plot <- ggplot() +
  geom_sf(data = eez_sf, aes(), fill = NA) +
  geom_sf(data = state_bf, aes(color = state), fill = NA)
#   

# ggsave("../Results/Partial/state_waters_buffer.png",state_bf_plot)

# ------------------------------ #

state_bf_plot

```

### 2. Expand grid within buffer

Here we expand a grid within the buffer so we can estimate the catch within

```{r grid_indexing, eval = T, echo = T, message = F, warning = F}

# Create grid of the region
bbox <- c(st_bbox(state_bf))

# Expand the grid
ne_grid <- expand.grid(
    lon = seq(from = bbox["xmin"], to = bbox["xmax"], by = 0.3),
    lat = seq(from = bbox["ymin"], to = bbox["ymax"], by = 0.3)
) %>% 
  rowid_to_column("index")

# ----------- #
# [TEST] Plot all layers
# ----------- #

# Looks good
state_sf %>%
  st_transform(4326) %>% # to match shape
  st_set_crs(4326) %>%
  st_simplify(preserveTopology = TRUE, dTolerance = 10000) %>%
  ggplot() +
  geom_sf(aes(color = state))+
  # geom_sf(data = eez_sf, aes(),fill =NA) +
  # ggplot()+
  geom_tile(data = ne_grid,
            aes(
              x = lon,
              y = lat
            ),
            alpha = 0.2
  ) 


```

#### 2.1 Merge grid and buffers

Here we converted the grid to `sf`, merged with the buffered states and filter out everything outside the states polygon

```{r grid_buf_merge, eval = T, echo = T, message = F, warning = F, fig.width = 10}

# ---------------- #
# Convert grid to sf
# ---------------- #
grid_sf <- st_as_sf(ne_grid,
             coords = c("lon", "lat"),
             crs = 4326) %>% 
  st_join(state_bf) %>% 
  filter(!is.na(state))

# Create data frame for future computations
# Note, will be used in next chunk
grid_bf_dt <- as.data.frame(grid_sf) %>%
    select(index,state)
    # group_by(state) %>% 
    # summarise(length(index))


# ---------------- #
# [TEST] 
# Visualization of grid
# ---------------- #

gridExtra::grid.arrange(
  # Overall (overlapping) position
  ggplot(grid_sf) +
    geom_sf(aes(color = state)) +
    geom_sf(data = eez_sf, aes(),fill =NA) + 
    theme(legend.position = ""),
  # Showing each state separatley
  ggplot() +
    geom_sf(data = grid_sf, aes(color = state),size = 0.1) +
    facet_wrap(~state) +
    theme(legend.position = "top"),
  nrow = 1)

```

### 3. Crop buffers to EEZ

```{r buff_to_eez, eval = T, echo = T, message = F, warning = F}


# I don't know how to undo st_simplify so need to re-load the shapefile
eez_sf <- st_read(dsn = path_world,
                        layer =file_path_sans_ext(fnam_world)) %>% 
  rename(eez_name = Name) %>% 
  st_transform(crs = 4326) %>% # 4326
  filter(eez_name == "USA (East Coast)")

# Get the overlapping segments
grid_eez_sf <- st_intersection(grid_sf,eez_sf)

# write_sf(grid_eez_sf, "../Results/Partial/grid_eez_sf.shp")

# Get final df with index
grid_eez_df <- as.data.frame(grid_eez_sf) %>%
  select(state,index)


# write_csv(grid_eez_df, "../Results/Partial/grid_eez_df.csv")

# Plot to make sure makes sense (Picasso syle)
# grid_eez_sf %>%
#   st_simplify(preserveTopology = TRUE, dTolerance = 10000) %>% #0.1 for paper
#   ggplot() +
#   geom_sf(aes(color = state))


```


## Map of smapling points

In this case the color gradient represents wtcpue (wet tones catch per unit of effort, haul hours) from 1972 to 2019. Grey dots represent `wtcpue = 0`

```{r survey_map, eval = F, echo = T, fig.width = 12, fig.height = 8}

ggplot(land_sf) +
  geom_sf() +
  geom_sf(data = eez_sf, aes(), fill = "white") +
  geom_point(data = subset(ocean_data, wtcpue = 0),
             aes(
               x = lon,
               y = lat
             ),
             color = "grey95",
             size = 1
  ) +
  geom_point(data = subset(ocean_data, wtcpue > 0),
             aes(
               x = lon,
               y = lat,
               color = log10(wtcpue)
             ),
             size = 1
  ) +
  scale_color_distiller(palette = "Spectral", 
                       guide_legend(title = "WCPUE per Haul (log10)")) + 
  coord_sf(xlim = c(-76, -65),ylim = c(35, 45)) +
  MyFunctions::my_ggtheme_m() +
  facet_wrap(~region)

```


# Interpolation

Here we [interpolate](https://swilke-geoscience.net/post/spatial_interpolation/) the survey data within the grid. We

## Prepare data

- We removed cases where `wtcpue < 0`


```{r prepare_data, eval = T, echo = T}

# Subset data
subset_data <- ocean_data %>% 
  filter(
    region == "Northeast US Spring",
    wtcpue > 0)

# Get grid
grd_template <- data.frame(index = grid_sf$index,
                       state = grid_sf$state,
                       st_coordinates(grid_sf))

```


## Fun. interpol

This is the main function used to interpolate the data per year. It follows a Triangular Irregular Surface method using the `interp::interp()` function.

```{r interpol_function, eval = T, echo = T}

tis <- function(input_data,yr){
  
  # print(paste(yr))
  
  data <- input_data %>% 
    filter(year == yr)
  
  if(nrow(data) == 0){
    return(tibble())
  }else{
    # Triangular Irregular Surface
    fit_tin <- interp::interp( # using {interp}
      x = data$lon,           # the function actually accepts coordinate vectors
      y = data$lat,
      z = data$wtcpue,
      xo = grd_template$X,     # here we already define the target grid
      yo = grd_template$Y,
      output = "points"
    ) %>% 
      bind_cols() %>% 
      bind_cols(grd_template) %>%
      mutate(year = yr) %>% 
      select(index, state, year, lon=x, lat=y, value = z)
    
    return(fit_tin)
  }
}

```

## Control pannel

```{r contro_pannel, eval = T, echo = T}

# Run interpolation for all years
years <- seq(1973,2019,1)

historic_tif <- bind_rows(
  lapply(years,tis,input_data = subset_data)
)


write_csv(historic_tif,
          paste0(my_path("R",),"interpolated_data.csv"))

```


# Results


```{r load_data}


# Periods
periods <-tibble(
  period = c(rep("a early",12),
             rep("b mid",12),
             rep("c late",12),
             rep("d now",12)
             ),
  year = c(seq(1972,1984,1),
            seq(1985,1997,1),
            seq(1998,2011,1),
            seq(2012,2019,1)
            )
  )

```


## Points

```{r area_plot, eval = T, echo = T}

 data_grid <- historic_tif %>% 
  # left_join(periods) %>% 
  # group_by(state,lat,lon,period) %>% 
  group_by(state,lat,lon) %>% 
  summarise(mean = mean(value,na.rm= T), .groups = "drop") %>% 
  rename(ID = state)

ggplot(data_grid) +
  geom_tile(
    aes(
      x = lon,
      y = lat,
      fill = mean,
      col = mean
    )
  ) +
  facet_wrap(~ ID) +
  scale_fill_viridis("Mean Proportion", alpha = 0.8) +
  scale_color_viridis("Mean Proportion", alpha = 0.8)


```

## Map

```{r area_plot, eval = T, echo = T}

total_fited <- historic_tif %>% 
  group_by(year) %>% 
  summarise(total_value = sum(value,na.rm=T))

state_fit <- historic_tif %>% 
  group_by(state,year) %>% 
  summarise(state_value = sum(value,na.rm= T), .groups = "drop") %>% 
  left_join(total_fited,
            by = "year") %>%
  mutate(percentage = state_value/total_value*100) %>% 
  left_join(periods) %>% 
  group_by(ID = state,period) %>% 
  summarise(mean_per = round(mean(percentage)))
  
# check percentages
# state_fit %>% 
#   group_by(period) %>% 
#   summarise(sum(mean_per))


land_sf %>% 
  left_join(state_fit,
            by = "ID") %>% 
  ggplot() +
  geom_sf(aes(fill = mean_per)) +
  viridis::scale_fill_viridis("Mean Proportion", alpha = 0.8) +
  facet_wrap(~period, nrow = 1) +
  my_ggtheme_m()

```

## Area plot

This graph shows the proportion of each State over time

```{r area_plot, eval = T, echo = T}

total_fited <- historic_tif %>% 
  group_by(year) %>% 
  summarise(total_value = sum(value,na.rm=T))

# group by state
state_fit <- historic_tif %>% 
  group_by(state,year) %>% 
  summarise(state_value = sum(value,na.rm= T), .groups = "drop") %>% 
  left_join(total_fited,
            by = "year") %>%
  mutate(percentage = state_value/total_value*100)


p <- ggplot(state_fit) +
  geom_area(
    aes(
      x = year,
      y = round(percentage),
      fill = state
    )
  ) +
  viridis::scale_fill_viridis(discrete = T, alpha = 0.8) +
  MyFunctions::my_ggtheme_p()

plotly::ggplotly(p)

```

